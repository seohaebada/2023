## 01. 캐싱의 원리와 목적

### 캐싱(Caching)
- Cache에 복사본을 저장해놓고 읽음으로써 속도가 느린 장치로서의 접근 횟수를 줄임 (임시 기억 장치)
- Cache의 데이터는 원본이 아니며 언제든 사라질 수 있음
- CPU 내의 Cache(속도가 빠름) -> RAM(속도가 느림)

### 캐싱 관련 개념들
- 캐시 적중 (Cache Hit) : 캐시에 접근해 데이터 발견
- 캐시 미스 (Cache Miss) : 캐시에 접근했는데 데이터 없음
- 캐시 삭제 정책 (Eviction Policy) : 캐시의 데이터 공간 확보를 위해 저장된 데이터를 삭제
- 캐시 전략 : 환경에 따라 적합한 캐시 운영 방식 선택 (Cache-Aside, Write-Through..)

### Cache-Aside (Lazy Loading)
- 항상 캐시를 먼저 체크하고, 없으면 원본에서 읽어온 후에 캐시에 저장함
- 최초 접근이 느릴 수 있음
- 업데이트 주기가 일정하지 않아서 캐시가 최신데이터가 아닐 수 있음 

### Write-Through
- 데이터를 쓸때 항상 캐시를 업데이트하여 최신 상태를 유지함
- 자주 사용하지 않는 데이터도 캐시되고, 쓰기 지연시간이 증가한다.
- 캐시는 항상 동기화되어있어 데이터가 최신이다.

### Write-Back
- 데이터를 캐시에만 쓰고, 캐시의 데이터를 일정 주기로 DB에 업데이트
- 쓰기가 많은 경우 DB 부하를 줄일 수 있음
- 캐시가 DB에 쓰기전에 장애가 생기면 데이터 유실 가능 

### 데이터 제거 방식
- 캐시에서 어떤 데이터를 언제 제거할 것인가?
- Expiration : 각 데이터에 TTL(Time-To-Live)을 설정해 시간 기반으로 삭제
- Eviction Algorithm : 공간을 확보해야할 경우 어떤 데이터를 삭제할지 결정하는 방식
  - LRU(Least Recently Used) : 가장 오랫동안 사용되지 않은 데이터 삭제
  - LFU(Least Frequently Used) : 가장 적게 사용된 데이터를 삭제 (최근에 사용되었더라도)
  - FIFO(First In First Out) :  먼저 들어온 데이터를 삭제

## 03. Spring의 캐싱 기능을 활용해 실제 비즈니스 로직 작성

### Spring의 캐시 추상화
- CacheManager를 통해 일반적인 캐시 인터페이스 구현 가능
- 메서드에 캐시를 손쉽게 적용 가능 (@Cacheable)
  - @Cacheable : 메서드에 캐시를 적용한다. (Cache-Aside 패턴 수행)
  - @CachePut : 메서드의 리턴값을 캐시에 설정한다.
  - @CacheEvict : 메서드의 키값을 기반으로 캐시를 삭제한다.
