package com.concurrency.chapter06.예제6_07_ExecutorService_동작주기관리;

/**
 [스레드풀 (thread pool)]
 스레드 풀은 이름 그대로 작업을 처리할 수 있는 동일한 형태의 스레드 풀의 형태로 관리한다.
 그리고 스레드 풀은 풀 내부의 스레드로 처리할 작업을 쌓아둬야한다. (작업 큐(work queue)와 굉장히 밀접하다)

 동작
 1) 먼저 작업 큐에서 실행할 다음 작업을 가져온다.
 2) 작업을 실행한다.
 3) 가져와 실행할 다음 작업이 나타날 떄까지 대기하는 일을 반복한다.

 풀 내부의 스레드를 사용해 작업을 실행하는 방법을 사용하면, 작업별로 매번 스레드를 생성해 처리하는 방법보다 많은 장점이 있다.
 1) 이전에 사용했던 스레드를 재사용하기 때문에 스레드를 계속해서 생성할 필요가 없다.
 2) 여러개의 요청을 처리하는데 필요한 시스템 자원이 줄어든다.
 3) 클라이언트가 요청을 보냈을때 해당 요청을 처리할 스레드가 이미 만들어진 상태로 대기하고 있기 때문에 작업을 실행하는데 딜레이가 발생하지 않아 전체적인 반응 속도로 향상된다.
 4) 스레드 풀의 크기를 적절히 조절해두면 하드웨어 프로세서가 쉬지 않고 동작할 수 있다.
 5) 하드웨어 프로세서가 바쁘게 동작하는 와중에도 메모리를 전부 소모하거나 여러 스레드가 한정된 자원을 두고 서로 경쟁하느라 성능을 까먹는 현상도 없앨 수 있다.

 [스레드풀 사용 메서드]
 1) newFixedThreadPool
 = 처리할 작업이 등록되면 그에따라 실제 작업할 스레드를 하나씩 생성한다.
 생성할 수 있는 스레드의 최대 개수는 제한되어 있다.
 제한된 개수까지 스레드를 생성하고 나면 더이상 생성하지 않고 스레드 수를 유지한다.

 2) newCachedThreadPool
 캐시 스레드 풀은 현재 풀에 갖고있는 스레드의 수가 처리할 작업의 수보다 많아서 쉬는 스레드가 많이 발생할때
 쉬는 스레드를 종료시켜 훨씬 유연하게 대응할 수 있다.
 처리할 작업의 수가 많아지면 필요한 만큼 스레드를 새로 생성한다.
 반면에 스레드의 수에는 제한을 두지 않는다.

 3) newSingleThreadExecutor
 단일 스레드로 동작하는 Executor
 작업을 처리하는 스레드가 단 하나다.
 만약 작업 중에 Exception이 발생해 비정상적으로 종료되면 새로운 스레드를 하나 생성해 나머지 작업을 실행한다.
 등록된 작업은 설정된 큐에서 지정하는 순서에 따라 반드시 순차적으로 처리된다.

 4) newScheduledThreadPool
 일정 시간 이후에 실행하거나 주기적으로 작업을 실행할 수 있으며, 스레드의 수가 고정되어있는 형태의 Executor.timer 클래스의 기능과 유사하다.


 [Executor 동작주기]
 Executor를 구현하는 클래스는 대부분 작업을 처리하기 위한 스레드를 생성하도록 되어있다.
 하지만 JVM은 모든 스레드가 종료되기 전에는 종료하지 않고 대기하기 때문에 Executor를 제대로 종료시키지 않으면
 JVM 자체가 종료되지 않고 대기하기도 한다.

 Executor는 작업을 비동기적으로 실행하기 때문에 앞서 실행시켰던 작업의 상태를 특정 시점에 정확하게 파악하기 어렵다.
 어떤 작업은 이미 완료됐을 수도 있고, 또 몇개의 작업은 아직 실행중일 수 있고,
 또다른 작업은 아직 큐에서 대기 상태에 머물러 있을 수도 있다.
 애플리케이션을 종료하는 과정을 보면 안전한 종료 방법도 있겠고, 강제적인 종료 방법도 있다.

 Executor가 애플리케이션에 스레드 풀 등의 서비스를 제공한다는 관점으로 생각해본다면,
 Executor도 종료 절차를 밟아야한다.
 그리고 종료절차를 밟는 동안 실행중이거나 대기중이던 작업을 어떻게 처리했는지 작업을 맡겼던 애플리케이션에게 알려줄 의무가 있다.

 이처럼 서비스를 실행하는 동작 주기와 관련해 Executor를 상속받은 ExecutorService 인터페이스에는 동작 주기를 관리할 수 있는 메서드가 여럿 있다.

 [ExecutorService의 동작 주기]
 - 실행중 (running)
 - 종료중 (shutting down)
 - 종료 (terminated)

 1) ExecutorService를 처음 생성했을때 실행중 상태로 동작한다.
 2) shutdown 메서드를 실행하면 안전한 종료 절차를 진행하며 종료중 상태로 들어간다.
 -> 이 상태에서는 새로운 작업을 등록받지 않으며, 이전에 등록된 작업까지는 모두 끝마칠 수 있다.
 3 ) shutdownNow 메서드를 실행하면 강제 종료 절차를 진행한다.
 -> 현재 진행중인 작업도 가능한 한 취소시키고, 실행되지 않고 대기중이던 작업은 더이상 실행시키지 않는다.

 ExecutorService의 하위 클래스인 ThreadPoolExecutor는 이미 종료 절차가 되거나 종료된 이후에 새로운 작업을 등록하려하면,
 실행 거절 핸들러(reject execution handler)를 통해 오류를 처리한다.
 실행 거절 핸들러에 따라 다르지만 등록하려 했던 작업을 조용히 무시할 수도 있고, RejectExecutionException을 발생시켜 오류를 처리하도록 할 수도있다.

 - awaitTermination() : ExecutorService가 종료 상태로 들어갈때까지 대기
 - isTerminated : 메서드를 주기적으로 호출해 종료 상태로 들어갈 수 있는지 확인

 */
public class ExecutorServiceEx {
//    ExecutorService
}
