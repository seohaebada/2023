package com.concurrency.chapter05.예제5_08과_예제5_09프로듀서_컨슈머패턴_데스크탑_예제;

/**
 * 블로킹큐(blocking queue)는 put과 take라는 핵심 메서드를 가지고있다.
 * offer, pool이라는 메서드도 있다.
 * 만약 큐가 가득 차있다면 pull 메서드는 값을 추가할 공간이 생길때까지 대기한다.
 * 반대로 큐가 비어있는 상태라면 take 메서드는 뽑아낼 값이 들어올때까지 대기한다.
 * 큐의 크기에 제한을 두지 않으면 항상 여유 공간이 있는 셈이므로 put 연산이 대기 상태에 들어가는 일이 발생하지 않는다.
 *
 * 블로킹 큐는 프로듀서-컨슈머 패턴을 구현할때 사용하기에 좋다.
 * 프러듀서-컨슈머 패턴은 '해야할 일' 목록에 가운데에 두고 작업을 만들어내는 주체와 작업을 처리하는 주체를 분리할 수 있기 때문에
 * 개발 과정을 좀더 명확하게 단순화시킬 수 있고, 작업을 생성하는 부분과 처리하는 부분이 각각 감당할 수 있는 부하를 조절할 수 있다는 장점이 있다.
 *
 * 프로듀서-컨슈머 패턴을 적용해 프로그램을 구현할때 블로킹 큐를 사용하는 경우가 많은데,
 * 예를들어 프로듀서는 작업을 새로 만들어 큐에 쌓아두고, 컨슈머는 큐에 쌓여있는 작업을 가져다 처리하는 구조다.
 * 프로듀서는 어떤 컨슈머가 몇개나 동작하고 있는지에 대해 전혀 신경쓰지 않을 수 있다.
 * 반대로 컨슈머 역시 프로듀서에 대해서 뭔가를 알고있어야 할 필요가 없다.
 *
 * 큐와 함께 쓰레드풀을 사용하는 경우가 바로 프로듀서-컨슈머 패턴을 활용하는 가장 흔한 경우라고 할 수 있다.
 * 작업 큐와 스레드 풀을 사용하는 부분은 Executor 프레임웍에서도 사용할 수 있다.
 *
 * 블로킹 큐를 사용하면 값이 들어올때까지 take 메서드가 알아서 멈추고 대기하기 때문에 컨슈머 코드를 작성하기가 편리하다.
 * 프로듀서가 컨슈머가 감당하지 못할 만큼 일을 만들어 내지 않는 한, 컨슈머는 작업을 끝내고 다음 작업이 들어올때까지 기다리게된다.
 * 서버 애플리케이션을 놓고 보면 클라이언트의 수가 적거나 요청량이 많지 않아
 * 이렇게 컨슈머가 '놀고있는'상황이 정상적일 수도 있다. 하지만 또 다른 경우에는 프로듀서와 컨슈머의 비율이 적절하지 않다고,
 * 즉 하드웨어의 자원을 효율적으로 사용하지 못하는 것으로 판단할 수도 있다.
 *
 * 블로킹 큐에는 그 외에도 offer 메서드가 있다.
 * offer 메서드는 큐에 값을 넣을 수 없을때 대기하지 않고 바로 공간이 모자라 추가할 수 없다는 오류를 알려준다.
 * 프로듀서가 작업을 많이 만들어 과부하에 이르는 상태를 좀더 효과적으로 처리할 수 있다.
 *
 * 블로킹 큐는 애플리케이션이 안정적으로 동작하도록 만들고자 할때 요긴하게 사용할 수 있다.
 * 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨씬 많은 작업이 생겨 부하가 걸리는 상황에서 작업량을 조절하여
 * 애플리케이션이 안정적으로 동작하도록 유도할 수 있다.
 *
 * 프로듀서-컨슈머 패턴을 사용하면 각각의 프로그램 코드는 서로를 연결하는 큐를 기준으로 서로 분리되지만,
 * 움직이는 동작 자체는 큐를 사이에 두고 서로 간접적으로 연결되어있다.
 * 생각하기에는 컨슈머가 항상 밀리지 않고 작업을 마쳐준다고 가정하고, 따라서 작업 큐에 제한을 둘 필요가 없을것이라고
 * 편하게 넘어갈 수도 있다. 하지만 이는 나중에 프로그램 구조를 뒤집어 엎어야하는 원인이 될 수 있다.
 *
 * [BlockingQueue]
 * 자바 클래스 라이브러리에는 BlockingQueue 인터페이스를 구현한 클래스 몇가지가 들어있다.
 * LinkedBlockingQueue, ArrayBlockingQueue 는 FIFO 형태의 큐다.
 * 이는 각각 LinkedList, ArrayList에 대응된다.
 * 대신 병렬프로그램 환경에서는 LinkedList나 ArrayList에서 동기화된 List 인스턴스를 뽑아 사용하는 것보다 성능이 좋다.
 * PriorityBlockingQueue클래스는 우선순위를 기준으로 동작하는 큐다.
 * FIFO가 아닌 다른 순서로 큐의 항목을 처리해야 하는 경우 손쉽게 사용할 수 있다.
 *
 * [SynchronousQueue]
 * SynchronousQueue 클래스도 BlockingQueue 인터페이스를 구현하는데, 큐에 항목이 쌓이지 않으며,
 * 따라서 큐 내부에 값을 저장할 수 있도록 공간을 할당하지 않아도 된다.
 * 대신 큐에 값을 추가하려는 스레드나 값을 읽어가려는 스레드의 큐를 관리한다.
 * 예를들어, 프로듀서-컨슈머 사이에 데이터를 담아둘 공간이 전혀 없고, 프로듀서는 컨슈머에 직접 데이터를 넘겨주는 구조다.
 * 큐를 구현하는 것치고는 굉장히 이상한 모양이라고 생각할 수 있지만,
 * 프로듀서-컨슈머가 직접 데이터를 주고받을때까지 대기하기 때문에 프로듀서에서 컨슈머로 데이터가 넘어가는 순간은 굉장히 짧아진다는 특징이 있다.
 * (일반적인 큐는 큐에 쌓이는 과정을 거치기 때문에 작업이 순차적으로 진행된다.)
 * SynchronousQueue 는 또한 컨슈머에게 데이터를 직접 넘겨주기 때문에, 넘겨준 데이터와 관련되어 컨슈머가 갖고있는
 * 정보를 프로듀서가 쉽게 넘겨받을 수도 있다.
 * (일반적인 큐라면 프로듀서는 자신이 추가한 작업을 어느 컨슈머가 가져가 처리했는지 알기 어렵다)
 * SynchronousQueue에는 큐에 추가된 데이터를 보간할 공간이 없으므로 put 메서드나 take 메서드를 호출하면
 * 호출한 메서드의 상대편 측에 해당하는 메서드를 다른 스레드가 호출할때까지 대기한다.
 * 이처럼 SynchronousQueue는 데이터를 넘겨 받을 수 있는 충분한 개수의 컨슈머가 대기하고 있는 경우에 사용하기 좋다.
 */
public class Main {
}
