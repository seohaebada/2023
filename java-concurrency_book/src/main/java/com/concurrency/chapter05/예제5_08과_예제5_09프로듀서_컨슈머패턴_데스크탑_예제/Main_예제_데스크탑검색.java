package com.concurrency.chapter05.예제5_08과_예제5_09프로듀서_컨슈머패턴_데스크탑_예제;

/**
 * 프로듀서-컨슈머 모델을 적용해볼 수 있는 좋은 프로그램 예제로 데스크탑 검색 프로그램을 들 수 있다.
 *
 * 데스크탑 검색 프로그램
 * 로컬 하드 디스크에 들어있는 문서를 전부 읽어들이면서 나중에 검색하기 좋게 색인을 만들어두는 작업을 한다.
 *
 * 구현할 FileCrawler 예제
 * - 디스크에 들어있는 디렉토리 계층 구조를 따라가면서 검색 대상 파일이라고 판단되는 파일의 이름을 작업 큐에 모두 쌓아 넣는 프로듀서
 *
 * 구현할 Indexer 예제
 * - 작업 큐에 쌓여있는 파일 이름을 뽑아내어 해당 파일의 내용을 색인하는 컨슈머
 *
 * 프로듀서-컨슈머 패턴을 사용하면, 멀티스레드를 사용하는 경우에 프로그램의 세부 기능을 쉽게 컴포넌트화 할 수 있다.
 * 코드의 가독성이 높아지고, 두개의 기능을 하나로 묶어서 구현하는 경우보다 재사용성이 훨씬 높아진다.
 * 두 클래스 사이의 작업 흐름은 블로킹 큐가 조절하기 때문에 코드가 훨씬 간결하고 가독성도 높다.
 *
 * 프로듀서와 컨슈머는 서로 독립적으로 실행된다.
 * 예를들어, 프로듀서의 작업은 디스크나 네트웍I/O에 시간을 많이 소모하고, 컨슈머는 CPU를 많이 사용하는 특성이 있다면,
 * 프로듀서와 컨슈머의 기능을 단일 스레드에서 순차적으로 실행하는 것보다 성능이 크게 높아질 수 있다.
 * 프로듀서와 컨슈머가 멀티스레드로 동작하는 수준에서 차이가 있다면, 프로듀서와 컨슈머가 긴밀하게 연결되어 있을수록 병렬처리 성능이 떨어진다.
 *
 * 예제5-9. 문서 파일을 찾아내는 기능고 파일의 내용을 색인하는 모듈 여러개를 각각의 스레드로 동작시킨다 (ProducerConsumer.java)
 * 프로그램 코드를 보면 알수있지만 색인을 담당하는 컨슈머 스레드는 계쏙해서 작업을 기다리느라 종료되지 않기 때문에,
 * 파일을 모두 찾아내 처리했음에도 불구하고 프로그램이 종료되지 않는 상황이 발생한다.
 * (이를 해결하는 방법은 7장에서 공부)
 * 프로듀서와 컨슈머에 해당하는 스레드를 직접 관리하지만, 대부분의 경우는 Executor 작업 실행 프레임웍을 사용하여 표현할 수 있다.
 * (Executor 내부에서 프로듀서-컨슈머 패턴을 사용하므로)
 *
 * [직렬 스레드 한정]
 * java.util.concurrent 패키지에 들어있는 블로킹 큐 관련 클래스는 모두 프로듀서 스레드에서 객체를 가져와 커늇머 스레드에 넘겨주는 과정이 동기화 되어있다.
 * (직렬 스레드 한정 기법 사용)
 * 프로듀서-컨슈머 패턴과 블로킹 큐는 가변 객체(mutable object)를 사용할때 객체의 소유권을 프로듀서에서 컨슈머로 넘기는 과정에서 직렬 스레드 한정 기법을 사용한다.
 * 스레드에 한정된 객체는 특정 스레드 하나만이 소유권을 가질 수 있는데, 객체를 안전한 방법으로 공개하면 객체에 대한 소유권을 이전할 수 있다.
 * 이렇게 소유권을 이전하고 나면 이전받은 컨슈머 스레드가 객체에 대한 유일한 소유권을 가지며, 프로듀서 스레드는 이전된 객체에 대한 소유권을 완전히 잃는다.
 * 이렇게 안전한 공개 방법을 사용하면 새로운 소유자로 지정된 스레드는 객체의 상태를 완벽하게 볼 수 있지만, 원래 소유권을 갖고있던 스레드는
 * 전혀 상태를 알 수 없게되어, 새로운 스레드 내부에 객체가 완전히 한정된다.
 * 물론 새로 소유권을 확보한 스레드가 객체를 마음껏 사용할 수 있다.
 *
 * 객체 풀(object pool)은 직렬 스레드 한정 기법을 잘 활용하는 예인데, 풀에서 소유하고 있던 객체를 외부 스레드에게 빌려주는 일이 본업이기 때문이다.
 * 풀 내부에 소유하고 있던 객체를 외부에 공개할때 적절한 동기화 작업이 되어있고,
 * 그와 함께 풀에서 객체를 빌려다 사용하는 스레드 역시 빌려온 객체를 외부에 공개하거나 풀에 반납한 이후에 계속해서 사용하는 등의 일을 하지 않는다면,
 * 풀 스레드와 사용자 스레드 간에 소유권이 원할하게 이전되는 모습을 볼 수 있다.
 *
 * 가변 객체의 소유권을 이전해야 할 필요가 있다면, 다른 객체 공개 방법을 사용할 수도 있다.
 * 항상 소유권을 이전받는 스레드는 단 하나여야한다.
 * 블로킹 큐를 사용하면 이런 점을 명확하게 지킬 수 있다.
 *
 * [작업 가로채키 패턴]
 * 모든 컨슈머가 각자의 덱을 갖는다.
 * 만약 특정 컨슈머가 자신의 덱에 들어있던 작업을 모두 처리하고나면 다른 컨슈머의 덱에 쌓여있는 작업 가운데
 * 맨 뒤에 추가된 작업을 가로채 가져올 수 있다.
 * 작업 가로채기 패턴은 그 특성상 컨슈머가 하나의 큐를 바라보면서 서로 작업을 가져가려고 경쟁하지 않기 때문에
 * 일반적인 프로듀서-컨슈머 패턴보다 규모가 큰 시스템을 구현하기에 적당하다.
 * 컨슈머가 다른 컨슈머의 큐에서 작업을 가져오려 하는 경우에도 앞이 아닌 맨 뒤의 작업을 가져오기 때문에 맨 앞의 작업을 가져가려는
 * 원래 소유자와 경쟁이 일어나지도 않는다.
 *
 *
 */
public class Main_예제_데스크탑검색 {
}
