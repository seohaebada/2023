## 스레드와 비용

단일 스레드 프로그램은 스케줄링 문제가 발생하지도 않고, 동기화 문제나 그에 따른 부하도 발생하지 않는다.
게다가 내부 자료의 일관성을 위한 락의 동기화도 필요 없다.
실행 스케줄링과 스레드 간의 조율을 하다보면 성능에 부정적인 비용이 발생한다.
따라서 스레드를 사용하는 경우, 병렬로 실행함으로써 얻을 수 있는 이득이 병렬로 실행하느라 드는 비용을 넘어서야 성능을 향상시킬 수 있다.

<br/>

### 컨텍스트 스위칭

1) 다른 스레드 없이 메인 스레드 1개만 스케줄링할 경우 
메인 스레드는 항상 실행된다.

2) CPU 개수 < 실행중인 스레드 개수
운영체제가 특정 스레드의 실행 스케줄을 선점하고 다른 스레드가 실행될 수 있도록 스케줄을 잡는다.

> 컨텍스트 스위칭 (Context Switching)
> 이처럼 하나의 스레드가 실행되다가 다른 스레드가 실행되는 순간을 말한다.
> 1) 먼저 현재 실행중인 스레드의 실행 상태를 보관해둔다.
> 2) 다음번에 실행되기로 스케줄된 다른 스레드의 실행 상태를 다시 읽어들인다.

운영체제와 JVM 역시 프로그램 스레드가 사용하는 것과 같은 CPU를 함께 사용하고 있다.
따라서 운영체제나 JVM이 CPU를 많이 사용하면 할수록 실제 프로그램 스레드가 사용할 수 있는 CPU의 양은 줄어든다.

컨텍스트가 변경되면서 다른 스레드를 실행하려면 해당 스레드가 사용하던 데이터가 프로세서의 캐시 메모리에 들어있지 않을 확률도 높다.
이 경우, 캐시에서 찾지 못한 내용을 다른 저장소에서 찾아와야 하기 때문에 원래 예정된 것보다 느리게 실행된다.
이를 대비하고자, 대부분의 스레드 스케줄러는 실행 대기중인 스레드가 밀려있다해도, 현재 실행중인 스레드에게 최소한의 실행 시간을 보장해준다.
그러면 컨텍스트 스위칭에 들어가는 시간과 비용을 나누는 효과를 볼 수 있고, 그 결과 인터럽트 받지않고 실행할 수 있는 최소한의 시간을 보장받기 때문에,
전체적인 성능이 향상되는 효과를 볼 수 있다.

스레드가 실행하다가 락을 확보하기 위해 대기하기 시작하면, 일반적으로 JVM은 해당 스레드를 일시적으로 정지시키고 다른 스레드가 실행되도록 한다.
특정 스레드가 빈번하게 대기 상태에 들어간다고 하면 스레드별로 할당된 최소 실행 시간조차 사용하지 못한 경우도 있다.
대기 상태에 들어가는 연산을 많이 사용하는 프로그램(블로킹 I/O 사용, 락 대기시간이 길거나, 상태 변수의 값을 기다리는 등)은 CPU를 주로 활용하는 프로그램보다
컨텍스트 스위칭 횟수가 훨씬 많아지고, 따라서 스케줄링 부하가 늘어나면서 전체적인 처리량이 줄어든다.

### 블로킹

경쟁하지 않는 상태에서의 동기화 작업은 전적으로 JVM 내부에서 처리할 수 있다.
하지만 경쟁 조건이 발생할때는 동기화 작업에 운영체제가 관여해야할 수 있는데,
운영체제가 관여하는 부분은 모두 일정량의 자원을 소모한다.
락을 놓고 경쟁하고 있다면, 락을 확보하지 못한 스레드는 항상 대기 상태에 들어가야 한다.
JVM은 스레드를 대기 상태에 둘때 두가지 방법을 사용할 수 있다.
1) 스핀 대기 (spin waiting)
락을 확보할 때까지 계속해서 재시도하는 방법

2) 운영체제가 제공하는 기능으로 스레드를 실제 대기 상태로 두는 방법

어느 쪽이 효율적이냐 하는  문제의 답은 '컨텍스트 스위칭'에 필요한 자원의 영과, 락을 확보할때까지 걸리는 시간에 크게 좌우된다.
대기 시간이 짧은 경우에는 1)번의 스핀대기 방법 효과적이다.
대기 시간이 긴 경우에는 2)번의 운영체제의 기능 호출하는 편이 더 효율적이다.

락을 확보하지 못했거나 I/O 관련 작업을 사용 중이라거나 기타 여러 가지 조건에 걸려 스레드가 대기 상태에 들어갈때는
두번의 컨텍스트 스위칭 작업이 일어나며, 이 과정에서 운영체제와 각종 캐시 등의 모듈이 연결돼있다.

> 두번의 컨텍스트 스위칭 작업 과정 
첫번째 컨텍스트 스위칭은 실행되도록 할당된 시간 이전에 대기 상태에 들어가느라 발생하는 것이고,
두번째는 락이나 기타 필요한 조건이 충족됐을때 다시 실행 상태로 돌아오는 컨텍스트 스위칭이다.
락을 확보하고자 경쟁하다가 대기 상태에 들어갈때, 락을 확보하고 있는 스레드에게도 부하가 생긴다.
필요한 작업을 마치고 락을 해제할때 운영체제에게 대기 상태에 들어간 스레드를 동작시키라고 요청해야하기 때문이다.

